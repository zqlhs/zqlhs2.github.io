<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简单有效的页面防止重复提交的操作]]></title>
    <url>%2F2017%2F06%2F08%2F%E7%AE%80%E5%8D%95%E6%9C%89%E6%95%88%E7%9A%84%E9%A1%B5%E9%9D%A2%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[操作如下： var isSubmit = true; // 在js顶部定义全局变量 if(isSubmit){ save(); }else{ crossAPI.tips(&quot;请勿重复提交数据！&quot;,3000); return false; } var save = function () { isSubmit = false; // 进入方法后 isSubmit 置为 false，在后续的点击提交时，便不会执行save方法 。。。 。。。 // 此处为你自己的执行保存的方法 if( 保存成功 ){ 关闭数据新增页面，并刷新查询页面的查询 }else{ // 保存失败，则页面提醒保存失败 isSubmit = true; // isSubmit 置为 true ,用以再次提交当前数据使用 } }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript页面效果</tag>
        <tag>防止重复提交</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自学编程成功概率有多少可能]]></title>
    <url>%2F2017%2F05%2F26%2F%E5%85%B3%E4%BA%8E%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>档案</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的表增删字段和增删索引]]></title>
    <url>%2F2017%2F05%2F26%2FMySQL%E7%9A%84%E8%A1%A8%E5%A2%9E%E5%88%A0%E5%AD%97%E6%AE%B5%E5%92%8C%E5%A2%9E%E5%88%A0%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[表添加字段： ALTER TABLE 表名 ADD COLUMN 表字段 varchar(50) DEFAULT NULL COMMENT &apos;字段描述&apos;; 表删除字段： ALTER TABLE 表名 DROP COLUMN 表字段 ; 字段建唯一索引：create index idx_province_id on 表名 (表字段 ); 上为索引 create index 字段的索引 on 表名 (表字段 ); 删除字段的索引：alter table 表名 drop index idx_province_id ; 上为索引 alter table 表名 drop 字段的索引 ;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>增删字段</tag>
        <tag>增删索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的表以及数据备份]]></title>
    <url>%2F2017%2F05%2F26%2FMySQL%E7%9A%84%E8%A1%A8%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[备份表方法： 此方法索引和increment值也会同步 CREATE TABLE tb_cab_bak LIKE tb_cab; // 同步建表 INSERT INTO tb_cab_bak SELECT * FROM tb_cab；// 同步数据 若只复制表中的部分内容的同时定义表中的字段信息： CREATE TABLE tb_cab_bak ( – 对copy的表中的ID进行主键约束 ID INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY ) AS ( SELECT ID,SNAME,SCORE FROM tb_cab_bak );]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面常用的设置：显示，隐藏，只读，不可编辑，取值，置空]]></title>
    <url>%2F2016%2F11%2F06%2F%E9%A1%B5%E9%9D%A2%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E7%BD%AE%EF%BC%9A%E6%98%BE%E7%A4%BA%EF%BC%8C%E9%9A%90%E8%97%8F%EF%BC%8C%E5%8F%AA%E8%AF%BB%EF%BC%8C%E4%B8%8D%E5%8F%AF%E7%BC%96%E8%BE%91%EF%BC%8C%E5%8F%96%E5%80%BC%EF%BC%8C%E7%BD%AE%E7%A9%BA%2F</url>
    <content type="text"><![CDATA[$(&quot;#id&quot;).val() // 获取值 $(&quot;#id&quot;).val(&apos;&apos;) // 清空值 $(&quot;#id&quot;).val(&apos;变量名&apos;) // 赋值 $(&quot;#id&quot;).css(&apos;display&apos;,&apos;block&apos;) // 显示选择的对象 $(&quot;#id&quot;).css(&apos;display&apos;,&apos;none&apos;) // 隐藏选择的对象 $(&quot;#msgIdTpl option[value=&apos;&quot;+msgIdTpl+&quot;&apos;]&quot;).attr(&quot;selected&quot;,true); // 锁定下拉结果并是=使下拉不可编辑 $(&quot;#id,#id2,#id3&quot;).attr(&quot;readonly&quot;,&quot;readonly&quot;); //多个选择设置只读属性 $(&quot;#id,#id2).attr(&quot;disabled&quot;, true); // 设置为不可用]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript页面效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作中重名判断的注意事项]]></title>
    <url>%2F2016%2F10%2F08%2F%E9%87%8D%E5%90%8D%E5%88%A4%E6%96%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[工作中重名判断的注意事项： 信息记录修改页面中重名判断如下： 首先定义一个js中的全局变量stillName，用于存储要修改的信息原名； 修改时判断 修改后名称是否 == 修改的信息原名，若等于则不进行重名判断，不然则反之； 但是这里所有的 == 判断 以及 数据的保存，都应该是“去除数据两边空格后”的结果， 否则，增减一个空格，判断结果也是不重名，而页面效果可看不到空格，给客户的视觉感受就是重名 代码如下： var stillName = “需要更改的信息原名” if(stillName != $.trim(newName) ) { // 此处是去数据库查找是否有信息含有 修改后名称 } 然后，在执行修改后数据保存的方法时传值注意：一定要也去掉空格 newName = $.trim(newName);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript页面效果</tag>
        <tag>重名判断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用VMware安装CentOS 6.4]]></title>
    <url>%2F2016%2F08%2F16%2F%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85CentOS-6-4%2F</url>
    <content type="text"><![CDATA[环境：Windows7 , VMware Workstation10, CentOS6.4 为什么选择CentOS ? 1.主流： 目前的Linux操作系统主要应用于生产环境，主流企业级Linux系统仍旧是RedHat或者CentOS 2.免费： RedHat 和CentOS差别不大，CentOS是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本 3.更新方便：CentOS独有的yum命令支持在线升级，可以即时更新系统，不像RED HAT那样需要花钱购买支持服务！ 安装步骤 第1步：首先安装VMware Workstation，只需点下一步即可，安装过程略 第2步：文件 → 新建虚拟机 或 直接点击 创建新的虚拟机 图标 第3步：选择 典型（推荐）→ 下一步 第4步：稍后安装操作系统 第5步：选择操作系统和版本 第6步：输入虚拟机名称和安装路径 第7步：设置磁盘大小 第8步：自定义硬件 第9步：选择CentOS安装镜像文件 第10步：点击完成 第11步：启动虚拟机 第12步：选择第一项，安装全新操作系统或升级现有操作系统 第13步：Tab键进行选择，选择Skip，退出检测 第14步：点击Next 第15步：选择语言，这里选择的是中文简体 第16步：选择键盘样式 第17步：选择存储设备 如果以前安装过虚拟机，会出现这个警告，选择是，忽略所有数据 第18步：输入主机名 第19步：配置网络 第20步：设置时区，勾选使用UTC时间 第21步：输入根用户（root）的密码 如果密码过于简单会出现提示，点击无论如何都使用 第22步：根据此Linux具体功能，选择不同的方式 第23步：选择现在自定义，自定义安装需要的软件，如桌面配置 可以根据具体的情况来配置，如可安Eclipse 还可以安装Java平台、Perl支持等 选择语言支持 第24步：点击下一步，开始安装 第25步：安装完成后，点击重新导引 第26步：点击前进按钮 第27步：点击是，同意许可，再点击前进按钮 第28步：创建用户 第29步：设置日期和时间，如果可以上网，勾选在网上同步日期和时间 最后点击前进，完成安装！]]></content>
      <categories>
        <category>虚拟机VMware</category>
      </categories>
      <tags>
        <tag>虚拟机VMware安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本的sql语句以及高级运算符和 多表查询]]></title>
    <url>%2F2016%2F07%2F20%2F%E5%9F%BA%E6%9C%AC%E7%9A%84sql%E8%AF%AD%E5%8F%A5%E4%BB%A5%E5%8F%8A%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%20%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[选择：select * from table1 where Id=1(Id=1为条件语句，根据自己情况自定义） 插入：insert into table1(field1,field2) values(value1,value2) 删除：delete from table1 where 范围 更新：update table1 set field1=value1 where 范围 查找：select * from table1 where field1 like ’%value1%’ —like的语法很精妙，查资料! 排序：select * from table1 order by field1,field2 [desc] 总数：select count * as totalcount from table1 求和：select sum(field1) as sumvalue from table1 平均：select avg(field1) as avgvalue from table1 最大：select max(field1) as maxvalue from table1 最小：select min(field1) as minvalue from table1 11、说明：几个高级查询运算词 A： UNION 运算符 UNION 运算符通过组合其他两个结果表(例如 TABLE1 和 TABLE2)并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时(即 UNION ALL)，不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。 B： EXCEPT 运算符 EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 C： INTERSECT 运算符 INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 注：使用运算词的几个查询结果行必须是一致的。 12、说明：使用外连接 A、left outer join： 左外连接(左连接)：结果集几包括连接表的匹配行，也包括左连接表的所有行。 SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c B：right outer join: 右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。 C：full outer join： 全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>SQL的各种基本操作</tag>
        <tag>MySQL的高级运算符</tag>
        <tag>多表查询之左连接，右连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL建库建表建索引建视图建主键]]></title>
    <url>%2F2016%2F05%2F20%2FMySQL%E5%BB%BA%E5%BA%93%E5%BB%BA%E8%A1%A8%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%BB%BA%E8%A7%86%E5%9B%BE%E5%BB%BA%E4%B8%BB%E9%94%AE%2F</url>
    <content type="text"><![CDATA[1、说明：创建数据库CREATE DATABASE db1(db1代表数据库表，可自命名)2、说明：删除数据库drop database db1(db1代表数据库表，可自命名)3、说明：备份sql server— 创建 备份数据的 deviceUSE masterEXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:\mssql7backup\MyNwind_1.dat’— 开始 备份BACKUP DATABASE pubs TO testBack4、说明：创建新表create table tb1(Id int not null primary key,name varchar,..)(tb1为数据表名，ID为字段，int为数据类型整型，not null为数据是否可为空，Primary Key为主键设置，其中not null,primary key为可选项，字段，数据类型自定义。）根据已有的表创建新表：A：create table tab_new like tab_old (使用旧表创建新表)B：create table tab_new as select col1,col2… from tab_old definition only5、说明：删除新表：drop table tb16、说明：添加主键：Alter table tabname add primary key(ID)(设置某字段为主键，ID可自由设置，主键数据不可重复）说明：删除主键：Alter table tabname drop primary key(ID)（删除某字段主键）7、说明：创建索引：create [unique] index idxname on tabname(col….)删除索引：drop index idxname注：索引是不可更改的，想更改必须删除重新建。8、说明：创建视图：create view viewname as select statement删除视图：drop view viewname]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>建库建表建索引建视图</tag>
        <tag>备份数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql进行大数据量查询的性能优化]]></title>
    <url>%2F2016%2F03%2F26%2FMysql%E8%BF%9B%E8%A1%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据库设计方面： 1、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 2、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。 如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 3、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时,查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半， 那么即使在sex上建了索引也对查询效率起不了作用。 4、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重 考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 5、应尽可能的避免更新索引数据列，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频 繁更新索引数据列，那么需要考虑是否应将该索引建为索引。 6、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每 一个字符，而对于数字型而言只需要比较一次就够了。 7、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 8、避免频繁创建和删除临时表，以减少系统表资源的消耗。 9、临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 10、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 create table，然后insert。 11、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 SQL语句方面： 1、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 2、应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描 如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 3、in 和 not in 也要慎用，否则会导致全表扫描。 如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 4、下面的查询也将导致全表扫描： select id from t where name like ‘%abc%’ 5、如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。 然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。 如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num 6、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。 如： select id from t where num/2=100 应改为: select id from t where num=100*2 7、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。 如： select id from t where substring(name,1,3)=’abc’ ——name以abc开头的id select id from t where datediff(day,createdate,’2005-11-30′)=0 ——‘2005-11-30’生成的id 应改为： select id from t where name like ‘abc%’ select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′ 8、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 9、不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的， 应改成这样： create table #t(„) 10、很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 11、任何地方都不要使用 select from t ，用具体的字段列表代替“”，不要返回用不到的任何字段。 12、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 13、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 14、尽量避免大事务操作，提高系统并发能力。 java方面： 1、尽可能的少造对象。 2、合理摆正系统设计的位置。大量数据操作，和少量数据操作一定是分开的。大量的数据操作，肯定不是ORM框架搞定的。 3、使用jDBC链接数据库操作数据。 4、控制好内存，让数据流起来，而不是全部读到内存再处理，而是边读取边处理。 5、合理利用内存，有的数据要缓存]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>大数据量查询</tag>
        <tag>查询优化</tag>
        <tag>sql语句优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript实现锁定网页、密码解锁效果（屏幕保护效果）]]></title>
    <url>%2F2015%2F12%2F10%2Fjavascript%E5%AE%9E%E7%8E%B0%E9%94%81%E5%AE%9A%E7%BD%91%E9%A1%B5%E3%80%81%E5%AF%86%E7%A0%81%E8%A7%A3%E9%94%81%E6%95%88%E6%9E%9C%EF%BC%88%E5%B1%8F%E5%B9%95%E4%BF%9D%E6%8A%A4%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[功能描述：打开一个网站的网页，过指定时间不动作，就会锁定页面，隐藏内容容器，显示一个容器用于输入密码，输入正确的密码来解锁。锁定后即使用户刷新页面，还是保留原来的状态。如已经锁定的，需要继续锁定，否则显示内容。 示例代码如下，通过document.onmouseover来实现多少分钟没有动作，使用计时器来实现。（此处建议，将下列方法单独提取到一个公共的js中，然后再引用到页面上） &lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; javascript实现系统屏幕保护效果(锁定网页) 内容内容内容内容内容内容 请输入解锁密码： if (document.cookie.indexOf(‘lock=1’) != -1) ShowContent(false); var delay = 10 * 1000,timer;//10s后锁定，修改delay为你需要的时间，单位毫秒 function startTimer() { clearTimeout(timer); timer = setTimeout(TimerHandler, delay); } function TimerHandler() { document.cookie = ‘lock=1’; document.onmousemove = null;//锁定后移除鼠标移动事件 ShowContent(false); } function ShowContent(show) { document.getElementById(‘dvContent’).style.display = show ? ‘block’ : ‘none’; document.getElementById(‘dvPassword’).style.display = show ? ‘none’ : ‘block’; } function check() { if (document.getElementById(‘txtPwd’).value == ‘123’) { document.cookie = ‘lock=0’; ShowContent(true); startTimer()//重新计时 document.onmousemove = startTimer; //重新绑定鼠标移动事件 } else alert(‘密码输入错误！！’); } window.onload = function () { document.onmousemove = startTimer; startTimer(); }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript页面效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中常用的各类正则表达式以及使用方式收录]]></title>
    <url>%2F2015%2F11%2F18%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E5%90%84%E7%B1%BB%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[效果上建议查看下面第二部分，如果自定义多变情况，建议使用第一部分； 选择合适自己的加入自己的js中 第一部分： 适用于更适合自己需求的自定义校验方式 特殊字符判断正则表达式 var regEn = /[`~!@#$%^&amp;*()_+&lt;&gt;?:”{},.\/;’[]]/im; var regCn = /[·！#￥（）：；“”‘、，|《。》？、【】[]]/im; var re = /([-])\1{1}/; //判断是否包含符合上述的正则表达式（定义一个js内方法校验特殊字符，使用该方法时调用即可） var isSpecialCharacter = function (characterStr,itemName) { if(regEn.test(characterStr) || regCn.test(characterStr)) { crossAPI.tips(itemName+”此处为描述信息，自己随便写！”, 3000); return true; } if(re.test(characterStr)) { crossAPI.tips(itemName+”此处为描述信息，自己随便写！”, 3000); return true; } return false; }第二部分： 文本框输入内容控制 更好的效果是input加上onkeyup，onbeforepaste，onblur，onkeydown等事件 使用：建议先定义好需要的正则表达式，再在事件中使用 如：自定义正则表达式.test(“要校验的变量名”) 整数或者小数：^[0-9]+\.{0,1}[0-9]{0,2}$ 只能输入数字：&quot;^[0-9]*$&quot;。 只能输入n位的数字：&quot;^\d{n}$&quot;。 只能输入至少n位的数字：&quot;^\d{n,}$&quot;。 只能输入m~n位的数字：。&quot;^\d{m,n}$&quot; 只能输入零和非零开头的数字：&quot;^(0|[1-9][0-9]*)$&quot;。 只能输入有两位小数的正实数：&quot;^[0-9]+(.[0-9]{2})?$&quot;。 只能输入有1~3位小数的正实数：&quot;^[0-9]+(.[0-9]{1,3})?$&quot;。 只能输入非零的正整数：&quot;^\+?[1-9][0-9]*$&quot;。 只能输入非零的负整数：&quot;^\-[1-9][]0-9&quot;*$。 只能输入长度为3的字符：&quot;^.{3}$&quot;。 只能输入由26个英文字母组成的字符串：&quot;^[A-Za-z]+$&quot;。 只能输入由26个大写英文字母组成的字符串：&quot;^[A-Z]+$&quot;。 只能输入由26个小写英文字母组成的字符串：&quot;^[a-z]+$&quot;。 只能输入由数字和26个英文字母组成的字符串：&quot;^[A-Za-z0-9]+$&quot;。 只能输入由数字、26个英文字母或者下划线组成的字符串：&quot;^\w+$&quot;。 验证用户密码：&quot;^[a-zA-Z]\w{5,17}$&quot;正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。 验证是否含有^%&amp;&apos;,;=?$\&quot;等字符：&quot;[^%&amp;&apos;,;=?$\x22]+&quot;。 只能输入汉字：&quot;^[\u4e00-\u9fa5]{0,}$&quot; 验证Email地址：&quot;^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;。 验证InternetURL：&quot;^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$&quot;。 验证电话号码：&quot;^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$&quot;正确格式为：&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX&quot;。 验证身份证号（15位或18位数字）：&quot;^\d{15}|\d{18}$&quot;。 验证一年的12个月：&quot;^(0?[1-9]|1[0-2])$&quot;正确格式为：&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;12&quot;。 验证一个月的31天：&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;正确格式为；&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;31&quot;。 匹配中文字符的正则表达式： [\u4e00-\u9fa5] 匹配双字节字符(包括汉字在内)：[^\x00-\xff] 应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） String.prototype.len=function(){return this.replace(/[^\x00-\xff]/g,&quot;aa&quot;).length;} 匹配空行的正则表达式：\n[\s| ]*\r 匹配html标签的正则表达式：&lt;(.*)&gt;(.*)&lt;\/(.*)&gt;|&lt;(.*)\/&gt; 匹配首尾空格的正则表达式：(^\s*)|(\s*$) 匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)* 匹配网址URL的正则表达式：http://([\w-]+\.)+[\w-]+(/[\w- ./?%&amp;=]*)?]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>输入框的输入限制效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this 和super 关键字的区别]]></title>
    <url>%2F2015%2F11%2F12%2FJAVA%E5%9F%BA%E7%A1%80%EF%BC%9Athis%20%E5%92%8Csuper%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[属性的区别：this访问本类中的属性，如果本类没有此属性则从父类中继续查找。super访问父类中的属性。 方法的区别：this访问本类中的方法，如果本类没有此方法则从父类中继续查找。super访问父类中的方法。 构造的区别：this调用本类构造，必须放在构造方法的首行。super调用父类构造，必须放在子类构造方法首行。 其他区别：this表示当前对象。super不能表示当前对象 1、this. 变量和super.变量 this.变量 调用的当前对象的变量； super.变量 直接调用的是父类中的变量。 2、this(参数)和super(参数)方法 this(参数) 调用（转发）的是当前类中的构造器； super(参数) 用于确认要使用父类中的哪一个构造器。 注意点： 1）在对拥有父类的子类进行初始化时，父类的构造方法也会执行，且优先于子类的构造函数执行；因为每一个子类的构造函数中的第一行都有一条默认的隐式语句super(); 2）this() 和super()都只能写在构造函数的第一行； 3）this() 和super() 不能存在于同一个构造函数中。第一，this()和super()都必须写在构造函数的第一行；第二，this()语句调用的是当前类的另一个构造函数而这个另一个构造函数中必然有一个父类的构造器，再使用super()又调用一次父类的构造器， 就相当于调用了两次父类的构造器，编译器不会通过； 4）this和super不能用于static修饰的变量，方法，代码块；因为this和super都是指的是对象（实例）。]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造器Constructor是否可被override]]></title>
    <url>%2F2015%2F10%2F08%2F%E6%9E%84%E9%80%A0%E5%99%A8Constructor%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%ABoverride%2F</url>
    <content type="text"><![CDATA[构造器Constructor是否可被override： 构造器不能被重写，不能用static修饰构造器，只能用public private protected这三个权限修饰符，且不能有返回语句。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面试常问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问控制符public,protected,private,以及默认的区别]]></title>
    <url>%2F2015%2F10%2F08%2F%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6public%2Cprotected%2Cprivate%2C%E4%BB%A5%E5%8F%8A%E9%BB%98%E8%AE%A4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[访问控制符public,protected,private,以及默认的区别： private只有在本类中才能访问； public在任何地方都能访问； protected在同包内的类及包外的子类能访问； 默认不写在同包内能访问。 是否可以继承String类？？？ String类是final类故不可以继承，一切由final修饰过的都不能继承。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面试常问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类和接口的区别]]></title>
    <url>%2F2015%2F10%2F08%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[抽象类和接口的区别： –语法层次 抽象类和接口分别给出了不同的语法定义。 –设计层次 抽象层次不同，抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、 行为，但是接口却是对类局部（行为）进行抽象。抽象类是自底向上抽象而来的，接口是自顶向下设计出来 的。 –跨域不同 抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在 概念本质上是一致的，仅仅是实现了接口定义的契约而已，”like-a”的关系。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面试常问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是泛型、为什么要使用以及泛型擦除]]></title>
    <url>%2F2015%2F10%2F08%2F%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%2F</url>
    <content type="text"><![CDATA[什么是泛型、为什么要使用以及泛型擦除： 泛型，即“参数化类型”。 创建集合时就指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。 Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程即类型擦 除。泛型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java 代码直接转换成普通java字节码。 类型擦除的主要过程如下： 1）.将所有的泛型参数用其 2）.移除所有的类型参数。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面试常问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重载和重写的区别]]></title>
    <url>%2F2015%2F10%2F08%2F%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[重载和重写的区别： –重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰 符可以不同，发生在编译时。 –重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访 问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面试常问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象和面向过程的区别]]></title>
    <url>%2F2015%2F10%2F08%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[面向对象和面向过程的区别： –面向过程 优点：性能比面向对象高，因为类调用时需要实例化，比较消耗资源；比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要因素。 缺点：没有面向对象易于维护，易复用，易扩展 –面向对象 优点：易维护，易复用，易扩展，由于面向对象有封装，继承，多肽性的特性，可以设计出低耦合的系统，使系统更加灵活，更加易于维护 缺点：性能比面向过程低]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面试常问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hashCode和equals方法的关系]]></title>
    <url>%2F2015%2F10%2F08%2FhashCode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[hashCode和equals方法的关系： –equals相等，hashcode必相等；hashcode相等，equals可能不相等]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面试常问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动装箱与拆箱]]></title>
    <url>%2F2015%2F10%2F08%2F%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[自动装箱与拆箱： 装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完 成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面试常问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的四个基本特性（抽象、封装、继承，多态）]]></title>
    <url>%2F2015%2F10%2F08%2FJava%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%EF%BC%88%E6%8A%BD%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%A4%9A%E6%80%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java的四个基本特性（抽象、封装、继承，多态）： –抽象：就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。 抽象包括两个方面：一个是数据抽象，一个是过程抽象。数据抽象也就是对象的属性。过程抽象是对象的行为特征。 –封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信 的进行封装隐藏。 封装分为属性的封装和方法的封装。 –继承：是对有着共同特性的多类事物，进行再抽象成一个类。这个类就是多类事物的父类。父类的意义在于 抽取多类事物的共性。 –多态：允许不同类的对象对同一消息做出响应。方法的重载、类的覆盖正体现了多态。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面试常问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String和StringBuffer、StringBuilder的区别]]></title>
    <url>%2F2015%2F10%2F08%2FString%E5%92%8CStringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[String和StringBuffer、StringBuilder的区别： –可变性 String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自 AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。 –线程安全性 String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与 StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf 等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。 –性能 每次对String 类型进行改变的时候，都会生成一个新的String 对象，然后将指针指向新的String 对象。 StringBuffer每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>面试常问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面动态输入框可点击增加，下拉列表可点击增加]]></title>
    <url>%2F2015%2F08%2F10%2F%E9%A1%B5%E9%9D%A2%E5%8A%A8%E6%80%81%E8%BE%93%E5%85%A5%E6%A1%86%E5%8F%AF%E7%82%B9%E5%87%BB%E5%A2%9E%E5%8A%A0%EF%BC%8C%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8%E5%8F%AF%E7%82%B9%E5%87%BB%E5%A2%9E%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[页面效果如下： 定义好下列两个方法，给 var addConfigList = function (index) { var $div = &apos; &lt;div class=&quot;t-list-search t-columns-2&quot; id=&quot;config&apos;+index+&apos;&quot; style=&quot;margin: 10px;&quot;&gt;&apos; + &apos; &lt;ul class=&quot;t-columns-group&quot; id = &quot;configContent&apos;+index+&apos;&quot;&gt;&apos; + &apos; &lt;li class=&quot;robcss-select&quot; &gt;&apos; + &apos; &lt;label &gt;字段类型&lt;/label&gt;&apos; + &apos; &lt;div&gt;&apos; + &apos; &lt;input type=&quot;radio&quot; name = &quot;configType&apos;+index+&apos;&quot; checked = &quot;true&quot; id = &quot;textType&apos;+index+&apos;&quot; value=&quot;0&quot; style=&quot;margin-top: 15px;&quot;&gt;文本框&apos; + &apos; &lt;input type=&quot;radio&quot; name = &quot;configType&apos;+index+&apos;&quot; id= &quot;selectType&apos;+index+&apos;&quot; value=&quot;1&quot; style=&quot;margin-top: 15px&quot;&gt;下拉框&apos; + &apos; &lt;/div&gt;&apos; + &apos; &lt;/li&gt;&apos; + &apos; &lt;li class=&quot;robcss-select&quot; id = &quot;configTitleArea&apos; +index+ &apos;&quot;&gt;&apos; + &apos; &lt;label style=&quot;width:10%&quot;&gt;字段标题&lt;/label&gt;&apos; + &apos; &lt;div&gt;&apos; + &apos; &lt;input name=&quot;configTitle&quot; id=&quot;configTitle&apos;+ index+&apos;&quot; type=&quot;text&quot; value=&quot;&quot; style=&quot;width: 60%;margin-right: 40px&quot; &gt;&apos; + &apos; &lt;a href=&quot;#nogo&quot; class = &quot;t-btn t-btn-xs t-btn-blue&quot; id = &quot;deleteName&apos;+index+&apos;&quot;&gt;删除此字段&lt;/a&gt;&apos; + &apos; &lt;/div&gt;&apos; + &apos; &lt;/li&gt;&apos; + &apos; &lt;/ul&gt;&apos; + &apos; &lt;/div&gt;&apos;; $(&quot;#configList&quot;).append($div); //绑定删除配置事件 $(&apos;#deleteName&apos;+ index, $el).on(&apos;click&apos;, function () { if ($(&apos;#configList&apos;).children().length &lt; 2) { crossAPI.tips(&quot;至少保留一行&quot;, 1500); }else{ $(&quot;#config&quot; + index, $el).remove(); } }); //绑定选中文本框事件 $(&apos;#textType&apos;+ index, $el).on(&apos;click&apos;, function () { $(&quot;#configTitleArea&quot; + index, $el).nextAll().remove(); }); //绑定选中下拉框事件 $(&apos;#selectType&apos;+ index, $el).on(&apos;click&apos;, function () { if($(&quot;#configContent&quot; +index).children().length &gt; 2){ return; }else{ addSelectInfo(index); } }); } //下拉框新增选项 var addSelectInfo = function (index,createIndex) { if(createIndex == &quot;&quot; || createIndex == null){ createIndex = index; } var $li = &apos; &lt;li class=&quot;robcss-select&quot; id = &quot;selectItem&apos;+ createIndex+ &apos;&quot; style=&quot;width: 30%;padding-left:65px&quot;&gt;&apos; + &apos; &lt;label&gt;选项:&lt;/label&gt;&apos; + &apos; &lt;div&gt;&apos; + &apos; &lt;input name = &quot;selectName&quot;&gt;&apos; + &apos; &lt;/div&gt;&apos; + &apos; &lt;/li&gt;&apos; + &apos; &lt;li class=&quot;robcss-select&quot; id = &quot;selectInfo&apos;+ createIndex+&apos;&quot; &gt;&apos; + &apos; &lt;div&gt;&apos; + &apos; &lt;a href=&quot;#nogo&quot; id = &quot;addSelectInfo&apos;+ createIndex+&apos;&quot; class = &quot;t-btn t-btn-xs t-btn-blue&quot;&gt;新增&lt;/a&gt;&apos; + &apos; &lt;a href=&quot;#nogo&quot; id = &quot;delSelectInfo&apos;+ createIndex+&apos;&quot; class = &quot;t-btn t-btn-xs t-btn-blue&quot;&gt;删除&lt;/a&gt;&apos; + &apos; &lt;/div&gt;&apos; + &apos; &lt;/li&gt;&apos;; $(&quot;#configContent&quot;+index).append($li); //绑定新增事件 $(&apos;#addSelectInfo&apos;+ createIndex, $el).on(&apos;click&apos;, function () { if($(&apos;#configContent&apos;+ index).children().length &gt;= 12){ crossAPI.tips(&quot;最多新建5个选项&quot;, 1500); }else{ var createIndex = ++num; addSelectInfo(index,createIndex); } }); //绑定删除事件 $(&apos;#delSelectInfo&apos;+ createIndex, $el).on(&apos;click&apos;, function () { if ($(&apos;#configContent&apos;+ index).children().length &lt; 6) { crossAPI.tips(&quot;至少保留一行&quot;, 1500); }else{ $(&quot;#selectItem&quot; + createIndex, $el).remove(); $(&quot;#selectInfo&quot; + createIndex, $el).remove(); } }); }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript页面效果</tag>
      </tags>
  </entry>
</search>
